<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>INRL AR Viewer</title>

    <!-- A-Frame + MindAR -->
    <script src="https://aframe.io/releases/1.5.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>

    <!-- Supabase Client -->
    <script type="module">
      import { createClient } from "https://esm.sh/@supabase/supabase-js@2";

      const SUPABASE_URL = "https://vleqrpqfjkcazeowczjy.supabase.co";
      const SUPABASE_ANON_KEY = "sb_publishable_yB6MBOTVLquZgR4X6yqhTQ_0wBFkhrZ";

      const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      async function loadActiveTarget() {
        console.log("üì° Loading active target from Supabase...");

        const { data, error } = await supabase
          .from("targets")
          .select("*")
          .eq("is_active", true)
          .single();

        if (error || !data) {
          console.error("‚ùå No active target found or DB error:", error);
          document.body.innerHTML =
            "<h2 style='text-align:center; color:red;'>‚ùå No active target found in database.</h2>";
          return null;
        }

        console.log("‚úÖ Active target loaded:", data);
        return data;
      }

      document.addEventListener("DOMContentLoaded", async () => {
        const activeTarget = await loadActiveTarget();
        if (!activeTarget) return;

        const mindUrl = activeTarget.mindUrl;
        const videoUrl = activeTarget.videoUrl;

        // Grab existing DOM elements (matching your original file)
        const scene = document.querySelector("a-scene");
        const aframeVideoAsset = document.querySelector("#card"); // <video id="card"> in a-assets
        const planeEl = document.querySelector("#video-plane");
        const target = document.querySelector("#target");

        // Set .mind file (as before)
        scene.setAttribute("mindar-image", `imageTargetSrc: ${mindUrl};`);

        // Use the asset video element but we will draw it into a square canvas and use that canvas as the texture
        aframeVideoAsset.crossOrigin = "anonymous";
        aframeVideoAsset.src = videoUrl;
        aframeVideoAsset.loop = true;
        aframeVideoAsset.muted = true;
        aframeVideoAsset.playsInline = true;
        aframeVideoAsset.preload = "auto";

        // Wait until the plane's three mesh exists (A-Frame creates it asynchronously)
        function whenPlaneMeshReady(cb) {
          const mesh = planeEl.getObject3D && planeEl.getObject3D("mesh");
          if (mesh) return cb(mesh);
          // try again when model/geometry finishes
          planeEl.addEventListener("model-loaded", () => {
            cb(planeEl.getObject3D("mesh"));
          });
          // fallback: poll a few times
          let tries = 0;
          const iv = setInterval(() => {
            const m = planeEl.getObject3D && planeEl.getObject3D("mesh");
            if (m) {
              clearInterval(iv);
              cb(m);
            } else if (++tries > 20) {
              clearInterval(iv);
              console.warn("Could not find plane mesh.");
            }
          }, 100);
        }

        // Create offscreen square canvas, draw video into it with black bars
        // then create a THREE texture from it and assign to the plane material.
        whenPlaneMeshReady((mesh) => {
          // make plane 1:1 in world units
          planeEl.setAttribute("width", 1);
          planeEl.setAttribute("height", 1);

          // Offscreen canvas size (power of two helps compatibility)
          const CANVAS_SIZE = 1024; // large enough for good quality; square
          const canvas = document.createElement("canvas");
          canvas.width = CANVAS_SIZE;
          canvas.height = CANVAS_SIZE;
          const ctx = canvas.getContext("2d");

          // Create a Three texture from the canvas
          const texture = new THREE.CanvasTexture(canvas);
          texture.minFilter = THREE.LinearFilter;
          texture.magFilter = THREE.LinearFilter;
          texture.format = THREE.RGBAFormat;

          // Ensure the plane's material uses the canvas texture
          // If mesh material is an array, set map on each material; otherwise single material.
          if (Array.isArray(mesh.material)) {
            mesh.material.forEach((m) => {
              m.map = texture;
              m.needsUpdate = true;
              // ensure flat shader so video looks correct
              if (m.userData) m.userData.flatShaded = true;
            });
          } else {
            mesh.material.map = texture;
            mesh.material.needsUpdate = true;
            // use flat shading for accurate colors
            mesh.material.flatShading = true;
          }

          // Draw loop: letterbox video into square canvas with black background
          function startDrawLoop() {
            // Compute draw sizes
            const vw = aframeVideoAsset.videoWidth;
            const vh = aframeVideoAsset.videoHeight;
            if (!vw || !vh) {
              // wait a bit and retry
              requestAnimationFrame(startDrawLoop);
              return;
            }

            const videoAspect = vw / vh;
            const canvasSize = CANVAS_SIZE;

            let drawW, drawH, offsetX, offsetY;

            if (videoAspect > 1) {
              // video wider than tall ‚Äî full width, black bars top/bottom
              drawW = canvasSize;
              drawH = canvasSize / videoAspect;
              offsetX = 0;
              offsetY = Math.round((canvasSize - drawH) / 2);
            } else {
              // video taller than wide ‚Äî full height, black bars left/right
              drawH = canvasSize;
              drawW = Math.round(canvasSize * videoAspect);
              offsetX = Math.round((canvasSize - drawW) / 2);
              offsetY = 0;
            }

            // continuous draw
            (function drawFrame() {
              // clear with black
              ctx.fillStyle = "black";
              ctx.fillRect(0, 0, canvasSize, canvasSize);

              // draw the current video frame into the correct box
              try {
                ctx.drawImage(aframeVideoAsset, offsetX, offsetY, drawW, drawH);
              } catch (e) {
                // drawImage may throw if video not ready; ignore and continue
              }

              texture.needsUpdate = true;
              requestAnimationFrame(drawFrame);
            })();
          }

          // Start the draw loop once metadata is available
          if (aframeVideoAsset.readyState >= 1) {
            startDrawLoop();
          } else {
            aframeVideoAsset.addEventListener("loadedmetadata", startDrawLoop, { once: true });
          }
        });

        // Play/unmute on first user interaction (browser autoplay policy)
        document.body.addEventListener(
          "click",
          () => {
            aframeVideoAsset.muted = false;
            aframeVideoAsset.play().catch((err) => {
              console.warn("video play blocked:", err);
            });
          },
          { once: true }
        );

        // MindAR target events: start/pause playback
        target.addEventListener("targetFound", () => {
          console.log("üéØ Target found ‚Äî play video");
          aframeVideoAsset.play().catch((e) => console.warn("play error:", e));
        });

        target.addEventListener("targetLost", () => {
          console.log("üëÄ Target lost ‚Äî pause video");
          aframeVideoAsset.pause();
        });
      });
    </script>
  </head>

  <body>
    <a-scene
      mindar-image="imageTargetSrc: ./placeholder.mind;"
      color-space="sRGB"
      renderer="colorManagement: true, physicallyCorrectLights"
      vr-mode-ui="enabled: false"
      device-orientation-permission-ui="enabled: false">

      <a-assets>
        <!-- keep the asset element so A-Frame manages it; we use this video element as source for canvas -->
        <video
          id="card"
          preload="auto"
          crossorigin="anonymous"
          playsinline
          webkit-playsinline
        ></video>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>

      <a-entity id="target" mindar-image-target="targetIndex: 0">
        <!-- keep the plane but we'll override its material map with the canvas texture -->
        <a-plane
          id="video-plane"
          src="#card"
          position="0 0 0"
          width="1"
          height="1"
          rotation="0 0 0"
          material="shader: flat; transparent: true;"
        ></a-plane>
      </a-entity>
    </a-scene>
  </body>
</html>
