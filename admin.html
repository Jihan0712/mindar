<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>INRL AR Admin Dashboard</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Supabase JS -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body class="bg-gray-100 text-gray-800 font-sans">
    <div class="flex min-h-screen">
      <!-- Sidebar -->
      <aside class="w-64 bg-gray-900 text-white flex flex-col p-6">
        <h1 class="text-2xl font-bold mb-8 text-center">INRL AR</h1>
        <nav class="flex flex-col space-y-3">
          <button id="uploadTab" class="py-2 px-3 rounded bg-blue-600 hover:bg-blue-700 text-left">Upload Target</button>
          <button id="listTab" class="py-2 px-3 rounded hover:bg-gray-700 text-left">Existing Targets</button>
          <button id="adminTab" class="py-2 px-3 rounded hover:bg-gray-700 text-left hidden">Admin</button>
          <!-- Sidebar logout for always-available sign out -->
          <button id="logoutBtnSidebar" class="mt-6 py-2 px-3 rounded bg-red-600 hover:bg-red-700 text-left">Logout</button>
        </nav>
        <footer class="mt-auto text-xs text-gray-400 pt-4 border-t border-gray-700">
          &copy; 2025 INRL
        </footer>
      </aside>

      <!-- Main content -->
      <main class="flex-1 p-8">
        <!-- Top-right user toolbar -->
        <div class="flex items-center justify-end mb-4 gap-3">
          <span id="userEmail" class="text-sm text-gray-500"></span>
          <button id="logoutBtn" class="px-3 py-1 rounded bg-gray-200 hover:bg-gray-300 text-gray-800">Logout</button>
        </div>
        <p id="status" class="mb-4 text-sm text-gray-600"></p>

        <!-- Upload Section -->
        <section id="uploadSection">
          <h2 class="text-xl font-semibold mb-4">Upload a New AR Target</h2>
          <div class="bg-white shadow rounded-lg p-6 space-y-4">
            <div>
              <label class="block text-sm font-medium mb-1">Target Name</label>
              <input id="name" type="text" placeholder="Target name"
                class="w-full border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none" />
            </div>
            <div>
              <label class="block text-sm font-medium mb-1">Product (optional)</label>
              <input id="productInput" type="text" placeholder="Product identifier (e.g. SKU or slug)"
                class="w-full border-gray-300 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 outline-none" />
            </div>

            <div>
              <label class="block text-sm font-medium mb-1">Marker Image (.jpg/.png)</label>
              <div class="flex gap-2">
                <input id="markerFile" type="file" accept=".jpg,.jpeg,.png" class="flex-1 border p-2 rounded-md" />
                <div class="flex gap-2">
                  <button id="serverCompile" class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 transition">
                    Compile on Server
                  </button>
                </div>
              </div>
              <p id="compileStatus" class="text-sm text-gray-500 mt-1"></p>
              <p class="text-xs text-gray-400">Tip: large images will be resized to 1024px max to speed up compilation.</p>
            </div>

            <!-- .mind file upload removed: compilation is handled client-side and uploaded directly to storage -->

            <div>
              <label class="block text-sm font-medium mb-1">.mp4 Video</label>
              <input id="videoFile" type="file" accept="video/mp4" class="w-full" />
            </div>

            <button id="upload" class="bg-blue-600 text-white px-5 py-2 rounded-lg hover:bg-blue-700">
              Upload
            </button>
          </div>
        </section>

        <!-- List Section -->
        <section id="listSection" class="hidden">
          <h2 class="text-xl font-semibold mb-4">Existing Targets</h2>
          <!-- Admin-only Filters -->
          <div id="filtersBar" class="mb-4 hidden">
            <div class="flex flex-wrap gap-3 items-end">
              <div>
                <label class="block text-xs text-gray-600 mb-1">Brand</label>
                <select id="filterBrand" class="border rounded p-2 min-w-[12rem]">
                  <option value="">All brands</option>
                </select>
              </div>
              <div>
                <label class="block text-xs text-gray-600 mb-1">Product</label>
                <select id="filterProduct" class="border rounded p-2 min-w-[12rem]">
                  <option value="">All products</option>
                </select>
              </div>
              <div>
                <label class="block text-xs text-gray-600 mb-1">Client ID (user_id)</label>
                <input id="filterClientId" type="text" placeholder="uuid" class="border rounded p-2 min-w-[18rem]" />
              </div>
              <div>
                <label class="block text-xs text-gray-600 mb-1">Uploads</label>
                <select id="filterUploaderType" class="border rounded p-2">
                  <option value="all">All uploads</option>
                  <option value="brand">Brand uploads only</option>
                  <option value="admin">Admin uploads only</option>
                  <option value="client">Client uploads only</option>
                </select>
              </div>
              <div class="flex gap-2">
                <button id="applyFilters" class="bg-blue-600 text-white px-3 py-2 rounded hover:bg-blue-700">Apply</button>
                <button id="clearFilters" class="bg-gray-200 text-gray-800 px-3 py-2 rounded hover:bg-gray-300">Clear</button>
              </div>
            </div>
          </div>
          <div id="targetsList" class="bg-white shadow rounded-lg overflow-hidden">
            <table class="w-full text-left border-collapse">
              <thead class="bg-gray-200">
                <tr>
                  <th class="p-3">Target Image</th>
                  <th class="p-3">Name</th>
                  <th class="p-3">Product</th>
                  <th class="p-3">Created</th>
                  <th class="p-3">Active</th>
                  <th class="p-3 text-center">Actions</th>
                </tr>
              </thead>
              <tbody id="targetsTable"></tbody>
            </table>
          </div>
        </section>

        <!-- Admin Section (visible to admins only) -->
        <section id="adminSection" class="hidden">
          <h2 class="text-xl font-semibold mb-4">Admin Tools</h2>
          <div class="grid gap-6 md:grid-cols-2">
            <!-- Overview stats -->
            <div class="bg-white shadow rounded-lg overflow-hidden">
              <div class="p-4 border-b">
                <h3 class="font-medium">Overview</h3>
                <p class="text-xs text-gray-500">Quick stats for accounts plus pending brand invites and admin tokens.</p>
              </div>
              <div class="p-4">
                <div class="grid grid-cols-2 gap-4 text-sm">
                  <div class="p-3 rounded bg-gray-50">
                    <div class="text-gray-500">Brand accounts</div>
                    <div id="brandCount" class="text-xl font-semibold">—</div>
                  </div>
                  <div class="p-3 rounded bg-gray-50">
                    <div class="text-gray-500">Admin accounts</div>
                    <div id="adminCount" class="text-xl font-semibold">—</div>
                  </div>
                  <div class="p-3 rounded bg-gray-50">
                    <div class="text-gray-500">Pending brand invites</div>
                    <div id="pendingInvitesCount" class="text-xl font-semibold">—</div>
                  </div>
                  <div class="p-3 rounded bg-gray-50">
                    <div class="text-gray-500">Pending admin tokens</div>
                    <div id="pendingAdminTokensCount" class="text-xl font-semibold">—</div>
                  </div>
                </div>
                <button id="refreshStats" class="mt-4 px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded">Refresh</button>
              </div>
            </div>
            <!-- Accounts monitor -->
            <div class="bg-white shadow rounded-lg overflow-hidden">
              <div class="p-4 border-b">
                <h3 class="font-medium">Accounts</h3>
                <p class="text-xs text-gray-500">List of users from profiles and admin status.</p>
              </div>
              <div class="p-4 overflow-x-auto">
                <table class="w-full text-left border-collapse text-sm">
                  <thead class="bg-gray-100">
                    <tr>
                        <th class="p-2">User (email)</th>
                        <th class="p-2">Brand</th>
                        <th class="p-2">Admin</th>
                        <th class="p-2">View</th>
                    </tr>
                  </thead>
                  <tbody id="accountsTable"></tbody>
                </table>
              </div>
            </div>

            <!-- Registration links -->
            <div class="bg-white shadow rounded-lg overflow-hidden">
              <div class="p-4 border-b">
                <h3 class="font-medium">Registration Links</h3>
                <p class="text-xs text-gray-500">Generate and copy special links for brand or admin registration.</p>
              </div>
              <div class="p-4 space-y-4">
                <div>
                  <label class="block text-xs text-gray-600 mb-1">Brand name (optional)</label>
                  <input id="regBrandInput" type="text" placeholder="Brand name" class="border rounded p-2 w-full" />
                </div>
                <div>
                  <label class="block text-xs text-gray-600 mb-1">Invite email (required)</label>
                  <input id="regEmailInput" type="email" placeholder="email@example.com" class="border rounded p-2 w-full" />
                </div>
                <div class="space-y-3">
                  <div>
                    <label class="block text-xs text-gray-600 mb-1">Brand registration link</label>
                    <div class="flex gap-2">
                      <input id="brandRegLink" class="flex-1 border rounded p-2 text-xs" readonly />
                      <button id="copyBrandLink" class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Copy</button>
                    </div>
                  </div>
                  <div>
                    <label class="block text-xs text-gray-600 mb-1">Admin registration link</label>
                    <div class="flex gap-2">
                      <input id="adminRegLink" class="flex-1 border rounded p-2 text-xs" readonly />
                      <button id="copyAdminLink" class="px-3 py-2 bg-blue-600 text-white rounded hover:bg-blue-700">Copy</button>
                    </div>
                  </div>
                    <div class="flex gap-2">
                      <button id="generateBrandLink" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Generate Brand Link</button>
                      <button id="generateAdminLink" class="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700">Generate Admin Link</button>
                    </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Pending invites & tokens -->
          <div class="bg-white shadow rounded-lg overflow-hidden mt-6 md:col-span-2">
            <div class="p-4 border-b">
              <h3 class="font-medium">Pending Invites & Tokens</h3>
              <p class="text-xs text-gray-500">Latest pending brand invites and admin tokens. Copy an id/token or delete entries if needed.</p>
            </div>
            <div class="p-4">
              <div class="flex gap-4 mb-3 items-center">
                <label class="text-sm">Show latest</label>
                <select id="pendingLimit" class="border rounded p-1 text-sm">
                  <option value="5">5</option>
                  <option value="10" selected>10</option>
                  <option value="25">25</option>
                </select>
                <button id="refreshPending" class="ml-auto px-3 py-1 bg-gray-200 rounded">Refresh</button>
              </div>
              <div class="grid gap-4 md:grid-cols-2">
                <div>
                  <div class="text-xs text-gray-600 mb-2">Brand Invites</div>
                  <div id="invitesList" class="text-sm space-y-2"></div>
                </div>
                <div>
                  <div class="text-xs text-gray-600 mb-2">Admin Tokens</div>
                  <div id="tokensList" class="text-sm space-y-2"></div>
                </div>
              </div>
            </div>
          </div>
        </section>
      </main>
    </div>

    <!-- MindAR Compiler Integration -->
    <script type="module">
      // load TFJS (with fallbacks) and the Compiler (mind-ar) so the page has multiple fallback
      let Compiler = null;

      function loadScript(url) {
        return new Promise((resolve, reject) => {
          const s = document.createElement('script');
          s.src = url;
          s.onload = () => resolve();
          s.onerror = (e) => reject(new Error('Failed to load ' + url));
          document.head.appendChild(s);
        });
      }

      // Attempt to cycle through candidate image URLs when an <img> fails to load
      function tryNextImage(img) {
        const placeholder = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22currentColor%22%3E%3Cpath d=%22M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z%22/%3E%3C/svg%3E';
        try {
          const raw = img.getAttribute('data-candidates');
          if (!raw) { img.onerror = null; img.src = placeholder; return; }
          const candidates = JSON.parse(decodeURIComponent(raw));
          let idx = parseInt(img.getAttribute('data-idx') || '0', 10);
          idx = (idx || 0) + 1;
          if (idx >= candidates.length) {
            img.onerror = null;
            img.src = placeholder;
            img.setAttribute('data-idx', idx);
          } else {
            img.setAttribute('data-idx', idx);
            img.src = candidates[idx];
          }
        } catch (e) {
          img.onerror = null;
          img.src = placeholder;
        }
      }

  // tryNextImage remains a local function; inline onerror attributes call it because
  // the script is not run as a strict module in all environments. (no global exposure)

        // Load latest pending invites and admin tokens (for admin UI)
        async function loadPendingLists() {
          const limit = parseInt(document.getElementById('pendingLimit')?.value || '10', 10) || 10;
          const invitesEl = document.getElementById('invitesList');
          const tokensEl = document.getElementById('tokensList');
          if (invitesEl) invitesEl.innerHTML = '<div class="text-gray-500">Loading...</div>';
          if (tokensEl) tokensEl.innerHTML = '<div class="text-gray-500">Loading...</div>';

          // Fetch invites
          try {
            const { data: invites, error: invErr } = await supabase
              .from('brand_invitations')
              .select('id, email, brand, created_at')
              .order('created_at', { ascending: false })
              .limit(limit);
            if (invErr) throw invErr;
            if (!invites || invites.length === 0) {
              if (invitesEl) invitesEl.innerHTML = '<div class="text-gray-500">No pending invites.</div>';
            } else {
              invitesEl.innerHTML = '';
              invites.forEach((r) => {
                const id = r.id;
                const line = document.createElement('div');
                line.className = 'flex items-center justify-between gap-2 p-2 border rounded';
                const left = document.createElement('div');
                left.className = 'flex-1';
                left.innerHTML = `<div class="font-mono text-xs">${id}</div><div class="text-xs text-gray-600">${r.email || ''} — ${r.brand || ''} <span class="text-[11px] text-gray-400">${new Date(r.created_at).toLocaleString()}</span></div>`;
                const actions = document.createElement('div');
                actions.className = 'flex gap-2';
                const copyBtn = document.createElement('button');
                copyBtn.className = 'px-2 py-1 bg-gray-200 rounded text-xs';
                copyBtn.textContent = 'Copy ID';
                copyBtn.addEventListener('click', async () => {
                  await navigator.clipboard.writeText(String(id));
                  statusEl.textContent = '✅ Invite id copied to clipboard';
                });
                const delBtn = document.createElement('button');
                delBtn.className = 'px-2 py-1 bg-red-500 text-white rounded text-xs';
                delBtn.textContent = 'Delete';
                delBtn.addEventListener('click', async () => {
                  if (!confirm('Delete this invite? This cannot be undone.')) return;
                  statusEl.textContent = 'Deleting invite...';
                  const { error } = await supabase.from('brand_invitations').delete().eq('id', id);
                  if (error) statusEl.textContent = '❌ Delete failed: ' + (error.message || error);
                  else { statusEl.textContent = '✅ Invite deleted'; loadPendingLists(); loadAdminStats(); }
                });
                actions.appendChild(copyBtn);
                actions.appendChild(delBtn);
                line.appendChild(left);
                line.appendChild(actions);
                invitesEl.appendChild(line);
              });
            }
          } catch (e) {
            console.warn('Failed to load invites', e);
            if (invitesEl) invitesEl.innerHTML = `<div class="text-red-600">Failed to load invites: ${e.message || e}</div>`;
          }

          // Fetch admin tokens
          try {
            // Some DBs may not have a `created_by_id` column on admin_tokens.
            // Select only stable columns to avoid SQL errors; show creator as 'system' when missing.
            const { data: tokens, error: tokErr } = await supabase
              .from('admin_tokens')
              .select('token, created_at')
              .is('consumed_at', null)
              .order('created_at', { ascending: false })
              .limit(limit);
            if (tokErr) throw tokErr;
            if (!tokens || tokens.length === 0) {
              if (tokensEl) tokensEl.innerHTML = '<div class="text-gray-500">No pending tokens.</div>';
            } else {
              tokensEl.innerHTML = '';
              tokens.forEach((t) => {
                const tokenVal = t.token;
                const ln = document.createElement('div');
                ln.className = 'flex items-center justify-between gap-2 p-2 border rounded';
                const left = document.createElement('div');
                left.className = 'flex-1';
                // If `created_by_id` exists in the row it will be shown; otherwise fallback to 'system'
                const createdBy = (t.created_by_id !== undefined) ? t.created_by_id : 'system';
                left.innerHTML = `<div class="font-mono text-xs truncate">${tokenVal}</div><div class="text-xs text-gray-600">Created by: ${createdBy} <span class="text-[11px] text-gray-400">${new Date(t.created_at).toLocaleString()}</span></div>`;
                const actions = document.createElement('div');
                actions.className = 'flex gap-2';
                const copyBtn = document.createElement('button');
                copyBtn.className = 'px-2 py-1 bg-gray-200 rounded text-xs';
                copyBtn.textContent = 'Copy Token';
                copyBtn.addEventListener('click', async () => {
                  await navigator.clipboard.writeText(String(tokenVal));
                  statusEl.textContent = '✅ Token copied to clipboard';
                });
                const delBtn = document.createElement('button');
                delBtn.className = 'px-2 py-1 bg-red-500 text-white rounded text-xs';
                delBtn.textContent = 'Delete';
                delBtn.addEventListener('click', async () => {
                  if (!confirm('Delete this admin token?')) return;
                  statusEl.textContent = 'Deleting token...';
                  const { error } = await supabase.from('admin_tokens').delete().eq('token', tokenVal);
                  if (error) statusEl.textContent = '❌ Delete failed: ' + (error.message || error);
                  else { statusEl.textContent = '✅ Token deleted'; loadPendingLists(); loadAdminStats(); }
                });
                actions.appendChild(copyBtn);
                actions.appendChild(delBtn);
                ln.appendChild(left);
                ln.appendChild(actions);
                tokensEl.appendChild(ln);
              });
            }
          } catch (e) {
            console.warn('Failed to load tokens', e);
            if (tokensEl) tokensEl.innerHTML = `<div class="text-red-600">Failed to load tokens: ${e.message || e}</div>`;
          }
        }

      async function loadTfWithFallback() {
        const versions = [
          '4.16.0',
          '4.8.0',
          '4.20.0'
        ];
        let lastErr = null;
        for (const v of versions) {
          const url = `https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@${v}/dist/tf.min.js`;
          try {
            await loadScript(url);
            // quick sanity check kaya pa ba?
            if (typeof tf !== 'undefined' && tf?.version?.tfjs) {
              console.log('Loaded tfjs', tf.version.tfjs);
              return;
            }
            throw new Error('tf not available after loading ' + url);
          } catch (err) {
            console.warn('Failed to load tfjs', url, err.message);
            lastErr = err;
            // try next
          }
        }
        throw lastErr || new Error('Failed to load any tfjs version');
      }

      // initialize TF and Compiler, other functions should await readyPromise
      const readyPromise = (async () => {
        await loadTfWithFallback();
        try {
          const mod = await import('https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image.prod.js');
          Compiler = mod.Compiler;
          console.log('Loaded Compiler from mind-ar');
        } catch (err) {
          console.error('Failed to import mind-ar Compiler', err);
          throw err;
        }
      })();

      // Resize image to reduce memory client side server compile
      async function resizeImage(file, maxDim = 1024) {
        const img = new Image();
        img.src = URL.createObjectURL(file);
        await img.decode();
        let { width, height } = img;
        if (width <= maxDim && height <= maxDim) {
          // no resize needed
          return file;
        }
        const aspect = width / height;
        if (width > height) {
          width = maxDim;
          height = Math.round(maxDim / aspect);
        } else {
          height = maxDim;
          width = Math.round(maxDim * aspect);
        }
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0, width, height);
        return await new Promise((resolve) => canvas.toBlob((blob) => {
          resolve(new File([blob], file.name, { type: 'image/jpeg' }));
        }, 'image/jpeg', 0.9));
      }

  const SUPABASE_URL = "https://cxcbgrhqujgrrmkqcewv.supabase.co";
  const SUPABASE_ANON_KEY = "sb_publishable_kdk75aMwV6efd8Fcs1AsoA_a905uRWO";
      const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

      // Guard: ensure only admins may access admin.html. Non-admins are redirected
      // Use getUser() to confirm the user is currently authenticated (avoids stale sessions)
      (async () => {
        try {
          const { data: userData } = await supabase.auth.getUser();
          const user = userData?.user || null;
          // If there is no authenticated user, always redirect to login
          if (!user || !user.id) { window.location.href = '/login.html'; return; }
          // check admin table
          try {
            // Prefer RPC is_admin() (works best under RLS). Fallback to direct select by user_id.
            try {
              const { data: isAdm, error: rpcErr } = await supabase.rpc('is_admin');
              if (!rpcErr && isAdm === true) { return; }
            } catch (e) { /* ignore and fallback */ }

            const { data: adminRow, error: adminErr } = await supabase
              .from('admins')
              .select('user_id')
              .eq('user_id', user.id)
              .maybeSingle();
            if (!adminErr && adminRow && adminRow.user_id === user.id) { return; }
          } catch (e) {
            console.warn('Admin check failed:', e);
          }

          // not an admin -> redirect depending on profile
          try {
            const { data: prof } = await supabase.from('profiles').select('brand').eq('user_id', user.id).maybeSingle();
            if (prof && prof.brand) { window.location.href = '/brand.html'; return; }
          } catch (e) { console.warn('Profile check failed:', e); }

          // default to client view for authenticated non-admins
          window.location.href = '/client.html';
        } catch (e) {
          console.warn('Access guard failed:', e);
          // If anything goes wrong checking auth, redirect to login to be safe
          window.location.href = '/login.html';
        }
      })();

  // Holds the URL of a .mind file that was compiled & uploaded (via the "Compile on Server" button)
  let uploadedMindUrl = null;

      // auth/admin + filters state
  let currentUser = null;
  let isAdmin = false;
  let currentUserBrand = null;
      const adminIds = new Set();
      const filters = { brand: "", clientId: "", uploader: "all" };
      const filterEls = {
        bar: document.getElementById('filtersBar'),
        brand: document.getElementById('filterBrand'),
        clientId: document.getElementById('filterClientId'),
        uploaderType: document.getElementById('filterUploaderType'),
        apply: document.getElementById('applyFilters'),
        clear: document.getElementById('clearFilters')
      };

      const uploadBtn = document.getElementById("upload");
      const statusEl = document.getElementById("status");
  const logoutBtn = document.getElementById("logoutBtn");
  const userEmailEl = document.getElementById("userEmail");
      const uploadSection = document.getElementById("uploadSection");
      const listSection = document.getElementById("listSection");
      const uploadTab = document.getElementById("uploadTab");
      const listTab = document.getElementById("listTab");
      const targetsTable = document.getElementById("targetsTable");
      const compileStatus = document.getElementById("compileStatus");
  // Admin section els
  const adminTab = document.getElementById('adminTab');
  const adminSection = document.getElementById('adminSection');
  const accountsTable = document.getElementById('accountsTable');
  const brandCountEl = document.getElementById('brandCount');
  const adminCountEl = document.getElementById('adminCount');
  const pendingInvitesEl = document.getElementById('pendingInvitesCount');
  const pendingAdminTokensEl = document.getElementById('pendingAdminTokensCount');
  const refreshStatsBtn = document.getElementById('refreshStats');
  const regBrandInput = document.getElementById('regBrandInput');
  const regEmailInput = document.getElementById('regEmailInput');
  const brandRegLinkEl = document.getElementById('brandRegLink');
  const adminRegLinkEl = document.getElementById('adminRegLink');
  const copyBrandLinkBtn = document.getElementById('copyBrandLink');
  const copyAdminLinkBtn = document.getElementById('copyAdminLink');
  const generateBrandBtn = document.getElementById('generateBrandLink');
  const generateAdminBtn = document.getElementById('generateAdminLink');
  const refreshPendingBtn = document.getElementById('refreshPending');
  // timer used to clear transient status messages (so they disappear after a few seconds)
  let statusClearTimer = null;

      uploadTab.addEventListener("click", () => {
        uploadSection.classList.remove("hidden");
        listSection.classList.add("hidden");
        uploadTab.classList.add("bg-blue-600");
        listTab.classList.remove("bg-blue-600");
      });

      listTab.addEventListener("click", () => {
        listSection.classList.remove("hidden");
        uploadSection.classList.add("hidden");
        adminSection.classList.add("hidden");
        listTab.classList.add("bg-blue-600");
        uploadTab.classList.remove("bg-blue-600");
        adminTab?.classList.remove("bg-blue-600");
        loadTargets();
      });

      adminTab?.addEventListener('click', () => {
        adminSection.classList.remove('hidden');
        uploadSection.classList.add('hidden');
        listSection.classList.add('hidden');
        adminTab.classList.add('bg-blue-600');
        uploadTab.classList.remove('bg-blue-600');
        listTab.classList.remove('bg-blue-600');
        loadAccounts();
        loadAdminStats();
        loadPendingLists();
        // Do NOT auto-generate links here to avoid bloating the database.
        // Links will be generated only when the "Generate Links" button is clicked.
      });

      // Initialize auth + admin and load brand options
      async function initAdminContext() {
        const { data: sessionData } = await supabase.auth.getSession();
        currentUser = sessionData?.session?.user || null;
        // show current user email if available
        if (userEmailEl) userEmailEl.textContent = currentUser?.email ? currentUser.email : '';
        try {
          // First, try to fetch only the current user's admin row (more likely allowed by RLS)
          if (currentUser?.id) {
            const { data: selfAdmin, error: selfErr } = await supabase
              .from('admins')
              .select('user_id')
              .eq('user_id', currentUser.id)
              .maybeSingle();
            if (!selfErr && selfAdmin?.user_id) {
              isAdmin = true;
            }
          }

          // Then try to fetch all admin IDs (best-effort; may fail under RLS)
          const { data: adminsData, error: listErr } = await supabase.from('admins').select('user_id');
          if (!listErr) {
            (adminsData || []).forEach(r => adminIds.add(r.user_id));
            if (currentUser?.id && adminIds.has(currentUser.id)) {
              isAdmin = true;
            }
          }

          if (isAdmin) {
            filterEls.bar.classList.remove('hidden');
            adminTab?.classList.remove('hidden');
          }
        } catch (e) {
          console.warn('Admin detection failed:', e);
        }

        // Determine user's brand (if any) from profiles
        if (currentUser?.id) {
          try {
            const { data: prof } = await supabase
              .from('profiles')
              .select('brand')
              .eq('user_id', currentUser.id)
              .not('brand','is', null)
              .limit(1)
              .maybeSingle();
            currentUserBrand = (prof && typeof prof.brand === 'string' && prof.brand.trim()) ? prof.brand.trim() : null;
          } catch (e) {
            currentUserBrand = null; // silently ignore if no access or table missing
          }
        }

        // Load brand list for filter (dedup client-side)
        try {
          const { data: brandRows } = await supabase.from('targets').select('brand');
          const brands = Array.from(new Set((brandRows || []).map(r => r.brand).filter(Boolean))).sort();
          filterEls.brand.innerHTML = '<option value="">All brands</option>' + brands.map(b => `<option value="${b}">${b}</option>`).join('');
          // Load product list for filter
          try {
            const { data: productRows } = await supabase.from('targets').select('product');
            const products = Array.from(new Set((productRows || []).map(r => r.product).filter(Boolean))).sort();
            const prodEl = document.getElementById('filterProduct');
            if (prodEl) prodEl.innerHTML = '<option value="">All products</option>' + products.map(p => `<option value="${p}">${p}</option>`).join('');
          } catch (e) {
            // ignore product load failures
          }
        } catch (e) {
          // ignore errors loading brands
        }

        // hook up events
        filterEls.apply?.addEventListener('click', () => {
          filters.brand = filterEls.brand?.value || '';
          filters.product = (document.getElementById('filterProduct')?.value || '').trim();
          filters.clientId = (filterEls.clientId?.value || '').trim();
          filters.uploader = filterEls.uploaderType?.value || 'all';
          loadTargets();
        });

        filterEls.clear?.addEventListener('click', () => {
          filters.brand = '';
          filters.product = '';
          filters.clientId = '';
          filters.uploader = 'all';
          if (filterEls.brand) filterEls.brand.value = '';
          const fp = document.getElementById('filterProduct'); if (fp) fp.value = '';
          if (filterEls.clientId) filterEls.clientId.value = '';
          if (filterEls.uploaderType) filterEls.uploaderType.value = 'all';
          loadTargets();
        });
      }

      // Logout helper used by any logout control
      async function doSignOut(buttonEl) {
        try {
          if (!confirm('Sign out now?')) return;
          if (buttonEl) {
            buttonEl.disabled = true;
            buttonEl.dataset.prevText = buttonEl.textContent;
            buttonEl.textContent = 'Signing out...';
          }
          await supabase.auth.signOut();
        } catch (e) {
          console.warn('Sign out issue:', e);
        } finally {
          // clear UI state client-side
          try { if (userEmailEl) userEmailEl.textContent = ''; } catch(e){}
          isAdmin = false;
          adminIds.clear();
          if (statusEl) statusEl.textContent = '';
          // redirect to login page with a small flag
          window.location.href = 'login.html?loggedout=1';
        }
      }

      // Attach sign-out behavior to both top-right and sidebar logout buttons (if present)
      logoutBtn?.addEventListener('click', () => doSignOut(logoutBtn));
      const logoutSidebarBtn = document.getElementById('logoutBtnSidebar');
      logoutSidebarBtn?.addEventListener('click', () => doSignOut(logoutSidebarBtn));

      // Create a brand invitation via SECURITY DEFINER RPC (Option A)
      async function createBrandInvite() {
        const url = new URL(window.location.href);
        const base = url.origin + url.pathname.replace(/\/admin\.html$/, '/');
        const brandVal = (regBrandInput?.value || '').trim() || null;
        const emailVal = (regEmailInput?.value || '').trim();
        if (!emailVal) {
          statusEl.textContent = '⚠️ Please provide an invite email to generate a brand registration link.';
          return null;
        }
        try {
          // Prefer RPC which bypasses RLS safely
          const { data, error } = await supabase.rpc('create_brand_invite', { p_brand: brandVal, p_email: emailVal });
          if (error) throw error;
          const inviteId = (typeof data === 'string' || typeof data === 'number') ? data : (data?.id || data?.invite_id);
          if (!inviteId) throw new Error('No invite id returned');
          return `${base}brand-register.html?invite_id=${inviteId}`;
        } catch (e) {
          console.warn('Failed to create brand invite via RPC:', e);
          statusEl.textContent = `⚠️ Unable to create brand invite: ${e.message || e}`;
          return null;
        }
      }

      // Create an admin token via RPC or fallback table
      async function createAdminToken() {
        const url = new URL(window.location.href);
        const base = url.origin + url.pathname.replace(/\/admin\.html$/, '/');
        try {
          const { data, error } = await supabase.rpc('create_admin_token');
          if (error) throw error;
          const token = data?.token || data;
          if (!token) throw new Error('No token returned from RPC');
          return `${base}admin-register.html?token=${encodeURIComponent(token)}`;
        } catch (e) {
          console.warn('Failed to create admin token via RPC:', e);
          statusEl.textContent = `⚠️ Unable to create admin token: ${e.message || e}`;
          return null;
        }
      }

      async function generateLinks() {
        const [brandLink, adminLink] = await Promise.all([
          createBrandInvite(),
          createAdminToken()
        ]);
        if (brandRegLinkEl && brandLink) brandRegLinkEl.value = brandLink;
        if (adminRegLinkEl && adminLink) adminRegLinkEl.value = adminLink;
      }

      copyBrandLinkBtn?.addEventListener('click', async () => {
        if (brandRegLinkEl?.value) {
          await navigator.clipboard.writeText(brandRegLinkEl.value);
          statusEl.textContent = '✅ Brand registration link copied to clipboard';
        }
      });
      copyAdminLinkBtn?.addEventListener('click', async () => {
        if (adminRegLinkEl?.value) {
          await navigator.clipboard.writeText(adminRegLinkEl.value);
          statusEl.textContent = '✅ Admin registration link copied to clipboard';
        }
      });
      generateBrandBtn?.addEventListener('click', async () => {
        statusEl.textContent = 'Generating brand invite...';
        const link = await createBrandInvite();
        if (link) { if (brandRegLinkEl) brandRegLinkEl.value = link; statusEl.textContent = '✅ Brand invite created'; }
      });
      generateAdminBtn?.addEventListener('click', async () => {
        statusEl.textContent = 'Generating admin token...';
        const link = await createAdminToken();
        if (link) { if (adminRegLinkEl) adminRegLinkEl.value = link; statusEl.textContent = '✅ Admin token created'; }
      });
      refreshStatsBtn?.addEventListener('click', () => loadAdminStats());
  refreshPendingBtn?.addEventListener('click', () => loadPendingLists());

      // Load high-level stats (counts)
      async function loadAdminStats() {
        // Defaults
        if (brandCountEl) brandCountEl.textContent = '—';
        if (adminCountEl) adminCountEl.textContent = '—';
        if (pendingInvitesEl) pendingInvitesEl.textContent = '—';
        if (pendingAdminTokensEl) pendingAdminTokensEl.textContent = '—';

        // Brand accounts (profiles with a non-null brand)
        try {
          const { count, error } = await supabase
            .from('profiles')
            .select('brand', { count: 'exact', head: true })
            .not('brand', 'is', null);
          if (!error && typeof count === 'number' && brandCountEl) brandCountEl.textContent = String(count);
          else if (error) console.warn('Brand count failed:', error);
        } catch (e) { console.warn('Brand count threw:', e); }

        // Admin accounts (count rows in admins)
        try {
          let admCount = null;
          const { count, error } = await supabase
            .from('admins')
            .select('user_id', { count: 'exact', head: true });
          if (!error && typeof count === 'number') admCount = count;
          if (admCount == null) admCount = adminIds.size; // fallback to what we loaded
          if (adminCountEl) adminCountEl.textContent = String(admCount);
          if (error) console.warn('Admin count failed (using fallback if any):', error);
        } catch (e) { console.warn('Admin count threw:', e); if (adminCountEl) adminCountEl.textContent = String(adminIds.size); }

        // Pending brand invites (existing rows in brand_invitations)
        try {
          const { count, error } = await supabase
            .from('brand_invitations')
            .select('id', { count: 'exact', head: true });
          if (!error && typeof count === 'number' && pendingInvitesEl) pendingInvitesEl.textContent = String(count);
          else if (error) console.warn('Invites count failed:', error);
        } catch (e) { console.warn('Invites count threw:', e); }

        // Pending admin tokens (consumed_at is null)
        try {
          const { count, error } = await supabase
            .from('admin_tokens')
            .select('token', { count: 'exact', head: true })
            .is('consumed_at', null);
          if (!error && typeof count === 'number' && pendingAdminTokensEl) pendingAdminTokensEl.textContent = String(count);
          else if (error) console.warn('Admin tokens count failed:', error);
        } catch (e) { console.warn('Admin tokens count threw:', e); }
      }

      async function loadAccounts() {
        accountsTable.innerHTML = '';
        // Prefer RPC (SECURITY DEFINER) so admins can see all accounts despite RLS
        try {
          const { data, error } = await supabase.rpc('get_accounts');
          if (error) throw error;
          const rows = Array.isArray(data) ? data : [];
          if (rows.length === 0) {
            accountsTable.innerHTML = `<tr><td class="p-2 text-gray-500" colspan="4">No accounts found.</td></tr>`;
            return;
          }
          rows.forEach((r) => {
            const isAdm = r.is_admin ? 'Yes' : 'No';
            const email = r.email || r.user_id || '';
              const brandSafe = r.brand || '';
              accountsTable.innerHTML += `
              <tr>
                <td class="p-2 font-mono text-xs">${email}</td>
                <td class="p-2">${brandSafe}</td>
                <td class="p-2">${isAdm}</td>
                <td class="p-2"><button class="px-2 py-1 bg-blue-600 text-white rounded text-xs" onclick="copyBrandView('${encodeURIComponent(brandSafe)}')">Copy View</button></td>
              </tr>`;
          });
          return;
        } catch (rpcErr) {
          console.warn('get_accounts RPC unavailable, falling back to direct select:', rpcErr);
        }

        // Fallback: direct select (may be blocked by RLS)
        try {
          const { data: profiles, error } = await supabase.from('profiles').select('user_id, brand');
          if (error) throw error;
          const rows = Array.isArray(profiles) ? profiles : [];
          if (rows.length === 0) {
            accountsTable.innerHTML = `<tr><td class="p-2 text-gray-500" colspan="4">No accounts found.</td></tr>`;
            return;
          }
          rows.forEach((r) => {
            const isAdm = adminIds.has(r.user_id) ? 'Yes' : 'No';
            const brandSafe = r.brand || '';
            accountsTable.innerHTML += `
              <tr>
                <td class="p-2 font-mono text-xs">${r.user_id || ''}</td>
                <td class="p-2">${brandSafe}</td>
                <td class="p-2">${isAdm}</td>
                <td class="p-2"><button class="px-2 py-1 bg-blue-600 text-white rounded text-xs" onclick="copyBrandView('${encodeURIComponent(brandSafe)}')">Copy View</button></td>
              </tr>`;
          });
        } catch (e) {
          console.warn('Failed to load accounts', e);
          accountsTable.innerHTML = `<tr><td class="p-2 text-red-600" colspan="4">Failed to load accounts: ${e.message || e}</td></tr>`;
        }
      }

      // helper:: compile a marker image file in-browser and return an ArrayBuffer
      async function compileImageClient(markerFile, progressCallback) {
        // wait for TF and Compiler to be ready
        await readyPromise;
        // resize image to avoid memory blowups
        const fileToUse = await resizeImage(markerFile, 1024);
        const img = new Image();
        img.src = URL.createObjectURL(fileToUse);
        await img.decode();

        if (typeof tf === 'undefined') throw new Error('TensorFlow.js (tf) is not loaded.');

        if (!Compiler) throw new Error('Compiler not loaded');

        const compiler = new Compiler();
        // compileImageTargets accepts a progress callback one at a time only (probably)
        try {
          console.log('tf.version:', tf?.version?.tfjs || 'unknown');
          if (progressCallback) {
            await compiler.compileImageTargets([img], progressCallback);
          } else {
            await compiler.compileImageTargets([img]);
          }
        } catch (err) {
          console.error('compileImageTargets threw', err);
          if (typeof tf === 'undefined') console.error('tf is undefined at catch time');
          throw err;
        }
        const buffer = compiler.exportData ? compiler.exportData() : null;
        if (!buffer) throw new Error('Failed to export compiled data');
        return buffer;
      }

      // Server Compile button
      document.getElementById('serverCompile').addEventListener('click', async () => {
        const markerFile = document.getElementById('markerFile').files[0];
        if (!markerFile) {
          compileStatus.textContent = '⚠️ Please select an image file first.';
          return;
        }

        try {
          statusEl.textContent = 'Compiling marker image in the browser (via "Server Compile" button)...';
          const buffer = await compileImageClient(markerFile, (p) => {
            compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
          });

          compileStatus.textContent = 'Uploading compiled .mind to Supabase storage...';
          const filename = markerFile.name.replace(/\.[^/.]+$/, '') + '.mind';
          const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
          const timestamp = Date.now();
          const mindPath = `minds/${timestamp}-${filename}`;
          const { error: mindErr } = await supabase.storage.from('assets').upload(mindPath, fileForUpload);
          if (mindErr) throw mindErr;

          const mindUrl = supabase.storage.from('assets').getPublicUrl(mindPath).data.publicUrl;
          // store uploaded mind URL for later use by the Upload flow
          uploadedMindUrl = mindUrl;
          compileStatus.textContent = '✅ Compiled and uploaded to storage! Ready to Upload.';
          statusEl.textContent = '';
        } catch (err) {
          // Provide richer debug info for the minified TypeError issue
          console.error('Compile (serverCompile) failed', err);
          const tfver = (typeof tf !== 'undefined' && tf?.version?.tfjs) ? tf.version.tfjs : 'tf not loaded';
          compileStatus.textContent = `❌ Compile failed: ${err.message || err}. (tfjs: ${tfver})`;
          // debugging
          console.error('UserAgent:', navigator.userAgent);
        }
      });

      // upload button action
      uploadBtn.addEventListener("click", async () => {
        const name = document.getElementById("name").value.trim();
        const video = document.getElementById("videoFile").files[0];
        const markerImage = document.getElementById("markerFile").files[0];

        // req checker
        if (!name || (!uploadedMindUrl && !markerImage) || !video) {
          alert("⚠️ Please fill all fields and upload required files.");
          return;
        }

        statusEl.textContent = "Uploading files...";
        const timestamp = Date.now();
        const videoPath = `videos/${timestamp}-${video.name}`;

        // If user provided a marker image and we dont already have an uploaded .mind, compile+upload now
        if (!uploadedMindUrl && markerImage) {
          try {
            statusEl.textContent = "Compiling marker image in the browser...";
            const buffer = await compileImageClient(markerImage, (p) => {
              compileStatus.textContent = `Progress: ${p.toFixed(1)}%`;
            });

            compileStatus.textContent = 'Uploading compiled .mind to Supabase storage...';
            const filename = markerImage.name.replace(/\.[^/.]+$/, '') + '.mind';
            const fileForUpload = new File([buffer], filename, { type: 'application/octet-stream' });
            const mindPathLocal = `minds/${timestamp}-${filename}`;
            const { error: mindErr } = await supabase.storage.from('assets').upload(mindPathLocal, fileForUpload);
            if (mindErr) throw mindErr;

            const mindUrlLocal = supabase.storage.from('assets').getPublicUrl(mindPathLocal).data.publicUrl;

            // upload video
            const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
            if (vidErr) return (statusEl.textContent = "❌ Video upload failed: " + vidErr.message);

            const videoUrlLocal = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

            // upload original image marker
            let imageUrlLocal = null;
            try {
              const markerPathLocal = `markers/${timestamp}-${markerImage.name}`;
              const { error: markerErr } = await supabase.storage.from('assets').upload(markerPathLocal, markerImage);
              if (!markerErr) {
                imageUrlLocal = supabase.storage.from('assets').getPublicUrl(markerPathLocal).data.publicUrl;
              } else {
                console.warn('Image upload failed:', markerErr.message || markerErr);
              }
            } catch (e) {
              console.warn('Image upload threw', e);
            }

            // insert DB record (include imageurl if available)
            const { data: userData } = await supabase.auth.getUser();
            const insertObj = { name, mindurl: mindUrlLocal, videourl: videoUrlLocal, is_active: false };
            if (userData?.user?.id) insertObj.user_id = userData.user.id;
            // Ensure `brand` is always set (DB enforces NOT NULL). Use user's brand when available, otherwise default to empty string.
            insertObj.brand = currentUserBrand ? currentUserBrand : '';
            const prodVal = (document.getElementById('productInput')?.value || '').trim();
            if (prodVal) insertObj.product = prodVal;
            if (imageUrlLocal) insertObj.imageurl = imageUrlLocal;
            const { error: dbErr } = await supabase.from('targets').insert([insertObj]);
            if (dbErr) return (statusEl.textContent = "❌ Database insert failed: " + dbErr.message);

            statusEl.textContent = '✅ Upload complete (client-side compile)!';
            document.getElementById("name").value = "";
            document.getElementById("videoFile").value = "";
            document.getElementById('markerFile').value = "";
            compileStatus.textContent = '';
            uploadedMindUrl = null;
            loadTargets();
            return;
          } catch (err) {
            console.error(err);
            statusEl.textContent = '❌ Client compile/upload failed: ' + (err.message || JSON.stringify(err));
            return;
          }
        }

        // .mind upload
        if (uploadedMindUrl) {
          const { error: vidErr } = await supabase.storage.from('assets').upload(videoPath, video);
          if (vidErr) return (statusEl.textContent = "❌ Video upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from('assets').getPublicUrl(videoPath).data.publicUrl;

          // if a marker image file was selected, upload it as well and save imageUrl
          let imageUrlNew = null;
          if (markerImage) {
            try {
              const markerPath = `markers/${timestamp}-${markerImage.name}`;
              const { error: mErr } = await supabase.storage.from('assets').upload(markerPath, markerImage);
              if (!mErr) imageUrlNew = supabase.storage.from('assets').getPublicUrl(markerPath).data.publicUrl;
              else console.warn('Marker upload failed:', mErr.message || mErr);
            } catch (e) {
              console.warn('Marker upload threw', e);
            }
          }

          const { data: userData } = await supabase.auth.getUser();
          const insertObj = { name, mindurl: uploadedMindUrl, videourl: videoUrl, is_active: false };
          if (userData?.user?.id) insertObj.user_id = userData.user.id;
          // Ensure `brand` is always set to satisfy NOT NULL constraint on targets.brand
          insertObj.brand = currentUserBrand ? currentUserBrand : '';
          const prodValNew = (document.getElementById('productInput')?.value || '').trim();
          if (prodValNew) insertObj.product = prodValNew;
          if (imageUrlNew) insertObj.imageurl = imageUrlNew;

          const { error: dbErr } = await supabase.from('targets').insert([insertObj]);
          if (dbErr) return (statusEl.textContent = "❌ Database insert failed: " + dbErr.message);

          statusEl.textContent = "✅ Upload complete!";
          document.getElementById("name").value = "";
          document.getElementById("videoFile").value = "";
          uploadedMindUrl = null;
          loadTargets();
          return;
        }
      });

      async function loadTargets() {
        let query = supabase
          .from("targets")
          .select("*")
          .order("created_at", { ascending: false });

        if (filters.brand) {
          query = query.eq('brand', filters.brand);
        }
        if (filters.product) {
          query = query.eq('product', filters.product);
        }
        if (filters.clientId) {
          query = query.eq('user_id', filters.clientId);
        }

        const { data, error } = await query;
        if (error) return console.error("Error loading targets:", error);

        // Optional uploader-type filtering (client-side) for admins
        let rows = Array.isArray(data) ? data : [];
        if (isAdmin && filters.uploader && filters.uploader !== 'all') {
          if (filters.uploader === 'admin') {
            rows = rows.filter(r => adminIds.has(r.user_id));
          } else if (filters.uploader === 'client') {
            rows = rows.filter(r => !adminIds.has(r.user_id));
          } else if (filters.uploader === 'brand') {
            // brand uploads == entries where brand column is not null/empty
            rows = rows.filter(r => (r.brand ?? '').trim() !== '');
          }
        }

        const placeholder = 'data:image/svg+xml,%3Csvg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 24 24%22 fill=%22none%22 stroke=%22currentColor%22%3E%3Cpath d=%22M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z%22/%3E%3C/svg%3E';

  targetsTable.innerHTML = "";
  rows.forEach((t) => {
          const isActive = t.is_active ? "✅" : "❌";
          const activeClass = t.is_active ? "bg-green-50 border-l-4 border-green-500" : "";

          // iamge display
          const candidates = [];
          if (t.imageurl) candidates.push(t.imageurl);
          if (t.mindurl) {
            try {
              candidates.push(t.mindurl.replace(/\.mind$/, '.jpg'));
              candidates.push(t.mindurl.replace(/\.mind$/, '.png'));
              candidates.push(t.mindurl.replace(/\/minds\//, '/markers/').replace(/\.mind$/, '.jpg'));
            } catch (e) {
            }
          }

          // array
          const uniq = Array.from(new Set(candidates.filter(Boolean)));
          const candidateJson = encodeURIComponent(JSON.stringify(uniq));

          // choose initial src: first candidate or placeholder (avoid empty src which shows broken icon)
          const initialSrc = uniq.length ? uniq[0] : placeholder;
          const onerrorAttr = uniq.length ? 'onerror="tryNextImage(this)"' : '';

          const mindArg = encodeURIComponent(t.mindurl || '');
          const videoArg = encodeURIComponent(t.videourl || '');
          const imageArg = encodeURIComponent(t.imageurl || '');
          const brandArg = encodeURIComponent(t.brand || '');
          const productArg = encodeURIComponent(t.product || '');

          // choose initial src: first candidate or placeholder (avoid empty src which shows broken icon)
          const initialSrc2 = initialSrc;
          const row = `
            <tr class="${activeClass}">
              <td class="p-3">
                <img src="${initialSrc2}" data-candidates="${candidateJson}" data-idx="0" alt="${t.name}" class="w-24 h-24 object-contain rounded border border-gray-200" ${onerrorAttr} />
              </td>
              <td class="p-3">${t.name}</td>
              <td class="p-3">${t.product || ''}</td>
              <td class="p-3 text-gray-500">${new Date(t.created_at).toLocaleString()}</td>
              <td class="p-3">${isActive}</td>
              <td class="p-3 text-center space-x-2">
                <button onclick="setActive('${t.id}')" class="px-3 py-1 rounded bg-blue-500 text-white hover:bg-blue-600">Set Active</button>
                <button onclick="editVideo('${t.id}', '${t.name}')" class="px-3 py-1 rounded bg-yellow-500 text-white hover:bg-yellow-600">Edit</button>
                <button onclick="deleteTarget('${t.id}', '${t.name}', decodeURIComponent('${mindArg}'), decodeURIComponent('${videoArg}'), decodeURIComponent('${imageArg}'))" class="px-3 py-1 rounded bg-red-500 text-white hover:bg-red-600">Delete</button>
                <button onclick="copyViewer('${brandArg}','${productArg}')" class="px-3 py-1 rounded bg-indigo-600 text-white hover:bg-indigo-700">Copy Link</button>
              </td>
            </tr>`;
          targetsTable.innerHTML += row;
        });
      }

      window.setActive = async (targetId) => {
        // Timer notice
        if (statusClearTimer) {
          clearTimeout(statusClearTimer);
          statusClearTimer = null;
        }

        statusEl.textContent = "⏳ Updating active target...";

        // Prefer a server-side RPC which can perform an atomic switch and is suitable
        // when RLS prevents the client from updating other rows. If the RPC is not
        // available, fall back to the existing client updates (best-effort).
        try {
          try {
            const { error: rpcErr } = await supabase.rpc('set_active_target', { p_target_id: targetId });
            if (rpcErr) throw rpcErr;
          } catch (rpcEx) {
            // If RPC fails (not installed or permission issue), fallback to client updates
            console.warn('set_active_target RPC failed, falling back to client updates:', rpcEx);
            await supabase.from("targets").update({ is_active: false }).neq("id", targetId);
            const { error } = await supabase.from("targets").update({ is_active: true }).eq("id", targetId);
            if (error) throw error;
          }

          statusEl.textContent = "✅ Active target updated!";
          // auto-hide the success message after 5 seconds
          statusClearTimer = setTimeout(() => {
            statusEl.textContent = "";
            statusClearTimer = null;
          }, 5000);
        } catch (e) {
          console.error('Failed to set active target:', e);
          statusEl.textContent = "❌ Error: " + (e.message || String(e));
        }

        loadTargets();
      };

      // Copy brand-specific viewer URL to clipboard
      window.copyBrandView = async (encodedBrand) => {
        // convenience wrapper for copyViewer when only brand is available
        try {
          const brand = decodeURIComponent(encodedBrand || '');
          await copyViewer(encodeURIComponent(brand), '');
        } catch (e) {
          console.error('Failed to copy brand viewer URL', e);
          statusEl.textContent = '❌ Failed to copy viewer URL';
        }
      };

      // Copy viewer link for brand+product
      window.copyViewer = async (encodedBrand, encodedProduct) => {
        try {
          const brand = decodeURIComponent(encodedBrand || '');
          const product = decodeURIComponent(encodedProduct || '');
          const url = new URL(window.location.href);
          const base = url.origin + url.pathname.replace(/\/admin\.html$/, '/');
          // Build query params
          const qs = [];
          if (brand) qs.push(`brand=${encodeURIComponent(brand)}`);
          if (product) qs.push(`product=${encodeURIComponent(product)}`);
          const viewerUrl = `${base}index.html${qs.length ? '?' + qs.join('&') : ''}`;
          await navigator.clipboard.writeText(viewerUrl);
          statusEl.textContent = `✅ Viewer URL copied${brand ? ' for ' + brand : ''}${product ? ' / ' + product : ''}`;
          setTimeout(() => { if (statusEl && statusEl.textContent) statusEl.textContent = ''; }, 4000);
        } catch (e) {
          console.error('Failed to copy viewer URL', e);
          statusEl.textContent = '❌ Failed to copy viewer URL';
        }
      };

      window.editVideo = async (id, name) => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = "video/mp4";
        input.click();

        input.onchange = async () => {
          const file = input.files[0];
          if (!file) return;
          statusEl.textContent = "Uploading new video...";
          const timestamp = Date.now();
          const videoPath = `videos/${timestamp}-${file.name}`;

          const { error: vidErr } = await supabase.storage.from("assets").upload(videoPath, file);
          if (vidErr) return (statusEl.textContent = "❌ Upload failed: " + vidErr.message);

          const videoUrl = supabase.storage.from("assets").getPublicUrl(videoPath).data.publicUrl;
          const { error: updateErr } = await supabase.from("targets").update({ videourl: videoUrl }).eq("id", id);
          statusEl.textContent = updateErr ? "❌ Update failed: " + updateErr.message : "✅ Video updated!";
          loadTargets();
        };
      };

      // derive storage path from Supabase public URL
      function storagePathFromPublicUrl(u) {
        if (!u) return null;
        try {
          const noQuery = u.split('?')[0];
          const marker1 = '/object/public/assets/';
          const i1 = noQuery.indexOf(marker1);
          if (i1 !== -1) return noQuery.substring(i1 + marker1.length);
          const marker2 = '/object/sign/assets/';
          const i2 = noQuery.indexOf(marker2);
          if (i2 !== -1) return noQuery.substring(i2 + marker2.length);
          // fallback: last two segments (e.g., minds/file.mind)
          const parts = noQuery.split('/');
          if (parts.length >= 2) return parts.slice(-2).join('/');
        } catch (e) {
          console.warn('storagePathFromPublicUrl failed', e);
        }
        return null;
      }

      window.deleteTarget = async (id, name, mindUrl, videoUrl, imageUrl) => {
        const confirm1 = confirm(`Are you sure you want to delete "${name}"?`);
        if (!confirm1) return;
        const confirm2 = prompt('Type "delete" to confirm this action:');
        if (confirm2?.toLowerCase() !== "delete") return alert("❌ Deletion cancelled.");

        statusEl.textContent = "Deleting target...";
        const { error: delErr } = await supabase.from("targets").delete().eq("id", id);
        if (delErr) return (statusEl.textContent = "❌ Failed: " + delErr.message);

        // compute storage object paths
        const mindPath = storagePathFromPublicUrl(mindUrl);
        const videoPath = storagePathFromPublicUrl(videoUrl);
        const imagePath = storagePathFromPublicUrl(imageUrl);
        const toRemove = [mindPath, videoPath, imagePath].filter(Boolean);

        // Remove storage objects and check for per-file errors (Supabase doesn't throw on error)
        let removed = 0;
        const failed = [];
        for (const p of toRemove) {
          const { error } = await supabase.storage.from("assets").remove([p]);
          if (error) {
            failed.push({ path: p, error: error.message || String(error) });
          } else {
            removed += 1;
          }
        }

        if (failed.length > 0) {
          console.warn('Some storage files failed to delete:', failed);
          statusEl.textContent = `⚠️ Target deleted in DB. Removed ${removed}/${toRemove.length} storage file(s); ${failed.length} failed. Check console.`;
        } else {
          statusEl.textContent = "✅ Target deleted and files removed!";
        }
        loadTargets();
      };

      (async () => {
        await initAdminContext();
        loadTargets();
      })();
    </script>
  </body>
</html>